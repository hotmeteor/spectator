<?php

namespace Spectator\Exceptions;

use Opis\JsonSchema\Errors\ErrorFormatter;
use Opis\JsonSchema\Errors\ValidationError;
use Spectator\Support\Format;
use Symfony\Component\Console\Exception\ExceptionInterface;

abstract class SchemaValidationException extends \Exception implements ExceptionInterface
{
    protected array $errors = [];

    /**
     * @return static
     */
    public static function withError(string $message, ValidationError $error): self
    {
        $instance = new static($message);

        $formatter = new ErrorFormatter();

        $instance->errors = $formatter->formatFlat($error);

        return $instance;
    }

    /**
     * Return the exception errors.
     */
    public function getErrors(): array
    {
        return $this->errors;
    }

    /**
     * Check if the exception has errors.
     */
    public function hasErrors(): bool
    {
        return count($this->errors) > 0;
    }

    /**
     * Given a schema and ValidationError, returns a helpful error message where the validation
     * errors are mapped over a structured schema representation.
     *
     * @param  array|object  $schema  A JSON schema.
     * @param  ValidationError  $validationError  A validation error generated by Opis\JsonSchema.
     */
    public static function validationErrorMessage($schema, ValidationError $validationError): string
    {
        // Capture the validation error as a map containing each (sub)error's location, keyword, and message.
        $errorFormatted = self::formatValidationError($validationError, false);

        // Capture the schema as a map of display strings keyed by a location.
        $schema = json_decode(json_encode($schema), true);
        $schemaFormatted = self::formatSchema($schema, '#', '', [], 0);

        // Create a map of all (sub)error's where the key is the "instanceLocation" and the value is the error.
        $errorLocationMap = [];

        if (isset($errorFormatted['errors'])) {
            foreach ($errorFormatted['errors'] as $subError) {
                $errorLocationMap[$subError['instanceLocation']] = $subError;
            }
        }

        // Create a map of all (sub)error's where the key is the "keywordLocation" with certain keywords
        // stripped away. The values are the errors.
        $errorKeywordLocationMap = [];

        if (isset($errorFormatted['errors'])) {
            foreach ($errorFormatted['errors'] as $subError) {
                $keywords = ['/required', '/properties', '/type', '/format'];
                $keywordLocation = str_replace($keywords, '', $subError['keywordLocation']);
                $errorKeywordLocationMap[$keywordLocation] = $subError;
            }
        }

        // Display each item. If the item is keyed by a location matching an error, then display the
        // error alongside the item.
        $strings = [];

        if (! is_null($schemaFormatted)) {
            foreach ($schemaFormatted as $key => $schemaItem) {
                if (isset($errorLocationMap[$key])) {
                    $schemaItem = self::colorize($schemaItem, Format::TEXT_LIGHT_GREY);
                    $strings[] = $schemaItem.' <== '.self::colorize($errorLocationMap[$key]['error'], Format::TEXT_RED);
                } elseif (isset($errorKeywordLocationMap[$key])) {
                    $schemaItem = self::colorize($schemaItem, Format::TEXT_LIGHT_GREY);
                    $strings[] = $schemaItem.' <== '.self::colorize($errorKeywordLocationMap[$key]['error'], Format::TEXT_RED);
                } else {
                    $strings[] = self::colorize($schemaItem, Format::TEXT_GREEN);
                }
            }
        }

        // Display the validation error alongside the expected schema with each (sub)error mapped over it.
        $errorFlat = self::colorize(implode("\n", self::formatValidationError($validationError, true)), Format::TEXT_LIGHT_GREY, Format::STYLE_ITALIC);

        return "---\n\n".$errorFlat."\n\n".implode("\n", $strings)."\n\n";
    }

    /**
     * Returns a formatted validation error.
     *
     * @param  ValidationError  $validationError  A validation error generated by Opis\JsonSchema.
     * @param  bool  $flat  Should the formatted error be flat (a simple array) or structured?
     * @return array|string
     */
    public static function formatValidationError(ValidationError $validationError, bool $flat = false)
    {
        $formatter = new ErrorFormatter();

        return ($flat) ? $formatter->formatFlat($validationError) :
            $formatter->formatOutput($validationError, 'basic');
    }

    /**
     * Recursive function that, given a schema, creates a map of underlying schema items intended display.
     * Each item is keyed/identified using the schema's "location" â€” with a format similar
     * to Opis\JsonSchema\Errors. The value for each item is a display string representing a schema item,
     * its type, and other relevant information, when provided.
     *
     * Here's an example map:
     *
     * [
     *     "#" => "object++"
     *     "#/status" => "    status*: string"
     *     "#/message" => "    message*: string"
     * ]
     *
     * And when output, it might be displayed as follows:
     *
     * object++
     *     status*: string
     *     message*: string
     *
     * Because the items are keyed by a "location" similar to Opis\JsonSchema\Errors. We can easily
     * overlay errors at the call site:
     *
     * object++ <== The properties must match schema: message
     *     status*: string
     *     message*: string <== The data (integer) must match the type: string
     *
     * @param  array  $schema  JSON schema represented as an array.
     * @param  string  $locationCurrent  The current location within the JSON schema structure.
     * @param  string  $keyCurrent  The key at the current location, if one is present.
     * @param  array  $keysRequired  The keys required at the current location, if provided.
     * @param  int  $indentLevel  Represents how much newly added values should be indented.
     */
    public static function formatSchema(array $schema, string $locationCurrent, string $keyCurrent, array $keysRequired, int $indentLevel): array
    {
        $keysAtLocation = array_flip(array_keys($schema));
        $schemaMap = [];

        // is this a polymorphic schema?
        $polymorphicKeys = array_filter($keysAtLocation, function ($key) {
            return $key == 'allOf' || $key == 'anyOf' || $key == 'oneOf';
        }, ARRAY_FILTER_USE_KEY);
        $polymorphicKeys = array_values(array_flip($polymorphicKeys));

        if (! empty($polymorphicKeys)) { // first, check for a polymorphic schema...
            $polymorphicKey = $polymorphicKeys[0];

            // create entry for polymorphic schema
            $locationCurrent .= '/'.$polymorphicKey;
            $displayString = self::schemaItemDisplayString($polymorphicKey, '', $keyCurrent, '');
            $schemaMap[$locationCurrent] = self::indentedDisplayString($displayString, $indentLevel);

            $indentLevel = ++$indentLevel;
            foreach ($schema[$polymorphicKey] as $index => $nextSchema) {
                $schemaMap = array_merge($schemaMap, self::formatSchema($nextSchema, $locationCurrent.'/'.$index, $keyCurrent, [], $indentLevel));
            }

            return $schemaMap;
        } elseif (isset($schema['type'])) { // otherwise, check for explicit schema type...
            // convert "type" to an array (to support single/multiple types)
            if (! is_array($schema['type'])) {
                $types = [$schema['type']];
            } else {
                $types = $schema['type'];
            }

            // is "null" an included type? if so, make note of it and remove it from the types array
            $nullable = false;
            $nullIndex = array_search('null', $types);
            if ($nullIndex) {
                $nullable = true;
                unset($types[$nullIndex]);
            }

            // is "nullable" defined on the item itself?
            if (isset($schema['nullable'])) {
                $nullable = $schema['nullable'];
            }

            // is this item required?
            $required = false;
            if (in_array($keyCurrent, $keysRequired)) {
                $required = true;
            }

            // compute modifiers
            $typeModifier = ($nullable) ? '?' : '';
            $keyModifier = ($required) ? '*' : '';

            // compute next location
            if ($keyCurrent !== '') {
                $locationCurrent .= '/'.$keyCurrent;
            }

            // handle each schema type
            foreach ($types as $type) {
                switch ($type) {
                    case 'object':
                        // does this object support additional properties?
                        $additionalProperties = true;
                        if (isset($schema['additionalProperties'])) {
                            if (is_bool($schema['additionalProperties'])) {
                                $additionalProperties = $schema['additionalProperties'];
                            }
                        }

                        if ($additionalProperties) {
                            $typeModifier = '++'.$typeModifier;
                        }

                        // create entry for object schema
                        $displayString = self::schemaItemDisplayString(
                            'object',
                            $typeModifier,
                            $keyCurrent,
                            $keyModifier
                        );
                        $schemaMap[$locationCurrent] = self::indentedDisplayString($displayString, $indentLevel);

                        // create entries for all object properties
                        $indentLevel = ++$indentLevel;
                        foreach ($schema['properties'] as $key => $nextSchema) {
                            if (isset($schema['required'])) {
                                $schemaMap = array_merge($schemaMap, self::formatSchema($nextSchema, $locationCurrent, $key, $schema['required'], $indentLevel));
                            } else {
                                $schemaMap = array_merge($schemaMap, self::formatSchema($nextSchema, $locationCurrent, $key, [], $indentLevel));
                            }
                        }
                        break;
                    case 'array':
                        // create entry for array schema
                        $displayString = self::schemaItemDisplayString('array', $typeModifier, $keyCurrent, $keyModifier);
                        $schemaMap[$locationCurrent] = self::indentedDisplayString($displayString, $indentLevel);

                        // create entry for array's items
                        $nextSchema = $schema['items'];
                        $schemaMap = array_merge($schemaMap, self::formatSchema($nextSchema, $locationCurrent.'/items', '', [], ++$indentLevel));

                        break;
                    default:
                        // create entry for basic schema
                        $finalType = isset($schema['enum']) ? $type.' ['.implode(', ', $schema['enum']).']' : $type;
                        $displayString = self::schemaItemDisplayString($finalType, $typeModifier, $keyCurrent, $keyModifier);
                        $schemaMap[$locationCurrent] = self::indentedDisplayString($displayString, $indentLevel);

                        break;
                }
            }
        }

        return $schemaMap;
    }

    /**
     * Applies modifiers to schema's key name and value, if provided. Then returns display string
     * for the schema.
     *
     * @param  string  $type  The schema's type (ex: allOf, object, string).
     * @param  string  $typeModifier  A modifier for the type (ex: "++" in "object++").
     * @param  string  $key  The schema's key (ex: "name" in "name: string").
     * @param  string  $keyModifier  A modifier for the key (ex: "?" in "string?").
     */
    protected static function schemaItemDisplayString(string $type, string $typeModifier = '', string $key = '', string $keyModifier = ''): string
    {
        $keyFinal = $key.$keyModifier;
        $typeFinal = $type.$typeModifier;

        return (empty($key)) ? $typeFinal : $keyFinal.': '.$typeFinal;
    }

    /**
     * Applies indentation to a display string and returns it.
     *
     * @param  string  $displayString  A string to display.
     * @param  int  $indentLevel  The level of indentation to apply to the display string.
     */
    protected static function indentedDisplayString(string $displayString, int $indentLevel = 0): string
    {
        return str_repeat('    ', $indentLevel).$displayString;
    }

    /**
     * Colorize text.
     */
    protected static function colorize(string $text, string $textColor, string $style = ''): string
    {
        return "\e[{$textColor};{$style}m{$text}\e[0m";
    }
}
