<?php

namespace Spectator\Exceptions;

use Opis\JsonSchema\Errors\ErrorFormatter;
use Opis\JsonSchema\Errors\ValidationError;
use Spectator\Support\Format;
use Symfony\Component\Console\Exception\ExceptionInterface;

abstract class SchemaValidationException extends \Exception implements ExceptionInterface
{
    /**
     * @var array
     */
    protected array $errors = [];

    /**
     * @param  string  $message
     * @param  ValidationError  $error
     * @return static
     */
    public static function withError(string $message, ValidationError $error): self
    {
        $instance = new static($message);

        $formatter = new ErrorFormatter();

        $instance->errors = $formatter->formatFlat($error);

        return $instance;
    }

    /**
     * @param  ValidationError  $error
     */
    protected function setErrors(ValidationError $error)
    {
        $formatter = new ErrorFormatter();

        $this->errors = $formatter->formatFlat($error);
    }

    /**
     * Return the exception errors.
     *
     * @return array
     */
    public function getErrors(): array
    {
        return $this->errors;
    }

    /**
     * Check if the exception has errors.
     *
     * @return bool
     */
    public function hasErrors(): bool
    {
        return count($this->errors) > 0;
    }

    /**
     * Given a schema and ValidationError, returns a helpful error message where the validation
     * errors are mapped over a structured schema representation.
     *
     * @param  array|object  $schema  A JSON schema.
     * @param  ValidationError  $validation_error  A validation error generated by Opis\JsonSchema.
     * @return string
     */
    public static function validationErrorMessage($schema, ValidationError $validation_error): string
    {
        // Capture the validation error as a map containing each (sub)error's location, keyword, and message.
        $error_formatted = self::formatValidationError($validation_error, false);

        // Capture the schema as a map of display strings keyed by a location.
        $schema = json_decode(json_encode($schema), true);
        $schema_formatted = self::formatSchema($schema, '#', '', [], 0);

        // Create a map of all (sub)error's where the key is the "instanceLocation" and the value is the error.
        $error_location_map = [];

        if (isset($error_formatted['errors'])) {
            foreach ($error_formatted['errors'] as $sub_error) {
                $error_location_map[$sub_error['instanceLocation']] = $sub_error;
            }
        }

        // Create a map of all (sub)error's where the key is the "keywordLocation" with certain keywords
        // stripped away. The values are the errors.
        $error_keyword_location_map = [];

        if (isset($error_formatted['errors'])) {
            foreach ($error_formatted['errors'] as $sub_error) {
                $keywords = ['/required', '/properties', '/type', '/format'];
                $keyword_location = str_replace($keywords, '', $sub_error['keywordLocation']);
                $error_keyword_location_map[$keyword_location] = $sub_error;
            }
        }

        // Display each item. If the item is keyed by a location matching an error, then display the
        // error alongside the item.
        $strings = [];

        if (! is_null($schema_formatted)) {
            foreach ($schema_formatted as $key => $schema_item) {
                if (isset($error_location_map[$key])) {
                    $schema_item = self::colorize($schema_item, Format::TEXT_LIGHT_GREY);
                    $strings[] = $schema_item.' <== '.self::colorize($error_location_map[$key]['error'], Format::TEXT_RED);
                } elseif (isset($error_keyword_location_map[$key])) {
                    $schema_item = self::colorize($schema_item, Format::TEXT_LIGHT_GREY);
                    $strings[] = $schema_item.' <== '.self::colorize($error_keyword_location_map[$key]['error'], Format::TEXT_RED);
                } else {
                    $strings[] = self::colorize($schema_item, Format::TEXT_GREEN);
                }
            }
        }

        // Display the validation error alongside the expected schema with each (sub)error mapped over it.
        $error_flat = self::colorize(implode("\n", self::formatValidationError($validation_error, true)), Format::TEXT_LIGHT_GREY, Format::STYLE_ITALIC);

        return "---\n\n".$error_flat."\n\n".implode("\n", $strings)."\n\n";
    }

    /**
     * Returns a formatted validation error.
     *
     * @param  ValidationError  $validation_error  A validation error generated by Opis\JsonSchema.
     * @param  bool  $flat  Should the formatted error be flat (a simple array) or structured?
     * @return array|string
     */
    public static function formatValidationError(ValidationError $validation_error, bool $flat = false)
    {
        $formatter = new ErrorFormatter();

        return ($flat) ? $formatter->formatFlat($validation_error) :
            $formatter->formatOutput($validation_error, 'basic');
    }

    /**
     * Recursive function that, given a schema, creates a map of underlying schema items intended display.
     * Each item is keyed/identified using the schema's "location" â€” with a format similar
     * to Opis\JsonSchema\Errors. The value for each item is a display string representing a schema item,
     * its type, and other relevant information, when provided.
     *
     * Here's an example map:
     *
     * [
     *     "#" => "object++"
     *     "#/status" => "    status*: string"
     *     "#/message" => "    message*: string"
     * ]
     *
     * And when output, it might be displayed as follows:
     *
     * object++
     *     status*: string
     *     message*: string
     *
     * Because the items are keyed by a "location" similar to Opis\JsonSchema\Errors. We can easily
     * overlay errors at the call site:
     *
     * object++ <== The properties must match schema: message
     *     status*: string
     *     message*: string <== The data (integer) must match the type: string
     *
     * @param  array  $schema  JSON schema represented as an array.
     * @param  string  $location_current  The current location within the JSON schema structure.
     * @param  string  $key_current  The key at the current location, if one is present.
     * @param  array  $keys_required  The keys required at the current location, if provided.
     * @param  int  $indent_level  Represents how much newly added values should be indented.
     * @return array
     */
    public static function formatSchema(array $schema, string $location_current, string $key_current, array $keys_required, int $indent_level): array
    {
        $keys_at_location = array_flip(array_keys($schema));
        $schema_map = [];

        // is this a polymorphic schema?
        $polymorphic_keys = array_filter($keys_at_location, function ($key) {
            return $key == 'allOf' || $key == 'anyOf' || $key == 'oneOf';
        }, ARRAY_FILTER_USE_KEY);
        $polymorphic_keys = array_flip($polymorphic_keys);

        if (! empty($polymorphic_keys)) { // first, check for a polymorphic schema...
            $polymorphic_key = $polymorphic_keys[0];

            // create entry for polymorphic schema
            $location_current .= '/'.$polymorphic_key;
            $display_string = self::schemaItemDisplayString($polymorphic_key, '', $key_current, '');
            $schema_map[$location_current] = self::indentedDisplayString($display_string, $indent_level);

            $indent_level = ++$indent_level;
            foreach ($schema[$polymorphic_key] as $index => $next_schema) {
                $schema_map = array_merge($schema_map, self::formatSchema($next_schema, $location_current.'/'.$index, $key_current, [], $indent_level));
            }

            return $schema_map;
        } elseif (isset($schema['type'])) { // otherwise, check for explicit schema type...
            // convert "type" to an array (to support single/multiple types)
            $types = [];
            if (! is_array($schema['type'])) {
                $types = [$schema['type']];
            } else {
                $types = $schema['type'];
            }

            // is "null" an included type? if so, make note of it and remove it from the types array
            $nullable = false;
            $null_index = array_search('null', $types);
            if ($null_index) {
                $nullable = true;
                unset($types[$null_index]);
            }

            // is "nullable" defined on the item itself?
            if (isset($schema['nullable'])) {
                $nullable = $schema['nullable'];
            }

            // is this item required?
            $required = false;
            if (in_array($key_current, $keys_required)) {
                $required = true;
            }

            // compute modifiers
            $type_modifier = ($nullable) ? '?' : '';
            $key_modifier = ($required) ? '*' : '';

            // compute next location
            if ($key_current !== '') {
                $location_current .= '/'.$key_current;
            }

            // handle each schema type
            foreach ($types as $type) {
                switch ($type) {
                    case 'object':
                        // does this object support additional properties?
                        $additional_properties = true;
                        if (isset($schema['additionalProperties'])) {
                            if (is_bool($schema['additionalProperties'])) {
                                $additional_properties = $schema['additionalProperties'];
                            }
                        }

                        if ($additional_properties) {
                            $type_modifier = '++'.$type_modifier;
                        }

                        // create entry for object schema
                        $display_string = self::schemaItemDisplayString(
                            'object',
                            $type_modifier,
                            $key_current,
                            $key_modifier
                        );
                        $schema_map[$location_current] = self::indentedDisplayString($display_string, $indent_level);

                        // create entries for all object properties
                        $indent_level = ++$indent_level;
                        foreach ($schema['properties'] as $key => $next_schema) {
                            if (isset($schema['required'])) {
                                $schema_map = array_merge($schema_map, self::formatSchema($next_schema, $location_current, $key, $schema['required'], $indent_level));
                            } else {
                                $schema_map = array_merge($schema_map, self::formatSchema($next_schema, $location_current, $key, [], $indent_level));
                            }
                        }
                        break;
                    case 'array':
                        // create entry for array schema
                        $display_string = self::schemaItemDisplayString('array', $type_modifier, $key_current, $key_modifier);
                        $schema_map[$location_current] = self::indentedDisplayString($display_string, $indent_level);

                        // create entry for array's items
                        $next_schema = $schema['items'];
                        $schema_map = array_merge($schema_map, self::formatSchema($next_schema, $location_current.'/items', '', [], ++$indent_level));

                        break;
                    default:
                        // create entry for basic schema
                        $final_type = isset($schema['enum']) ? $type.' ['.implode(', ', $schema['enum']).']' : $type;
                        $display_string = self::schemaItemDisplayString($final_type, $type_modifier, $key_current, $key_modifier);
                        $schema_map[$location_current] = self::indentedDisplayString($display_string, $indent_level);

                        break;
                }
            }

            return $schema_map;
        }
    }

    /**
     * Applies modifiers to schema's key name and value, if provided. Then returns display string
     * for the schema.
     *
     * @param  string  $type  The schema's type (ex: allOf, object, string).
     * @param  string  $type_modifier  A modifier for the type (ex: "++" in "object++").
     * @param  string  $key  The schema's key (ex: "name" in "name: string").
     * @param  string  $key_modifier  A modifier for the key (ex: "?" in "string?").
     * @return string
     */
    protected static function schemaItemDisplayString(string $type, string $type_modifier = '', string $key = '', string $key_modifier = ''): string
    {
        $key_final = $key.$key_modifier;
        $type_final = $type.$type_modifier;

        return (empty($key)) ? $type_final : $key_final.': '.$type_final;
    }

    /**
     * Applies indentation to a display string and returns it.
     *
     * @param  string  $display_string  A string to display.
     * @param  int  $indent_level  The level of indentation to apply to the display string.
     * @return string
     */
    protected static function indentedDisplayString(string $display_string, int $indent_level = 0): string
    {
        return str_repeat('    ', $indent_level).$display_string;
    }

    /**
     * Colorize text.
     *
     * @param  string  $text
     * @param  string  $text_color
     * @param  string  $style
     * @return string
     */
    protected static function colorize(string $text, string $text_color, string $style = ''): string
    {
        return "\e[{$text_color};{$style}m{$text}\e[0m";
    }
}
